<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
    <canvas id="c" class="webgl"></canvas>
    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform sampler2D baseTexture;
        uniform sampler2D bloomTexture;

        varying vec2 vUv;

        void main() {
            gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
        }
    </script>

    <script type="module">
        import * as THREE from './three/build/three.module.js'
        import { OrbitControls } from './three/examples/jsm/controls/OrbitControls.js'
        import { EffectComposer } from './three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from './three/examples/jsm/postprocessing/RenderPass.js';
        import {UnrealBloomPass} from "./three/examples/jsm/postprocessing/UnrealBloomPass.js"
        import { FBXLoader } from './three/examples/jsm/loaders/FBXLoader.js'
        import { ShaderPass } from './three/examples/jsm/postprocessing/ShaderPass.js'

        let scene, camera, renderer, bloomComposer, finalComposer, loadFBXLandscape;
        var materials = {};
        let landscapeList = new Queue();
        const maxLandscapeLength = 10;
        let darkMaterial = new THREE.MeshBasicMaterial()
        darkMaterial.color.set(0x000000);

        let ENTIRE_SCENE = 0,
            BLOOM_SCENE = 1;
        let bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_SCENE);

        const params = {
            exposure: 0,
            bloomStrength: 1,
            bloomThreshold: 0.1,
            bloomRadius: 0.5
        };

        init();

        function init() {
            // const assetPath = 'models';

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 30000 );
        
            const ambient = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambient);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize( window.innerWidth, window.innerHeight);

            document.body.appendChild(renderer.domElement);

            const controls = new OrbitControls( camera, renderer.domElement );
            controls.maxPolarAngle = Math.PI * 0.5;

            loadBoxSky()
        
            const renderScene = new RenderPass( scene, camera );

            const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
            bloomPass.threshold = params.bloomThreshold;
            bloomPass.strength = params.bloomStrength;
            bloomPass.radius = params.bloomRadius;

            bloomComposer = new EffectComposer( renderer );
            bloomComposer.renderToScreen = false;
            bloomComposer.addPass( renderScene );
            bloomComposer.addPass( bloomPass );

            let finalPass = new ShaderPass(
                new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: bloomComposer.renderTarget2.texture }
                },
                vertexShader: document.getElementById("vertexshader").textContent,
                fragmentShader: document.getElementById("fragmentshader").textContent,
                defines: {}
                }),
                "baseTexture"
            );

            finalPass.needsSwap = true;
            finalComposer = new EffectComposer(renderer);
            finalComposer.setSize(
            window.innerWidth * window.devicePixelRatio,
            window.innerHeight * window.devicePixelRatio
            );

            finalComposer.addPass(renderScene);
            finalComposer.addPass(finalPass);

            camera.position.z = 0;
            camera.position.y = 0.3;
            camera.position.x = -1.15;

            const loader = new FBXLoader();
            // loader.setPath("models")
            loader.load("models/landscape.fbx", object => {
                loadFBXLandscape = object;
                RoadGenerator();
                update();
            })

            // let geometry = new THREE.BoxGeometry(4, 4, 4);
            // let MESH = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0x9100E7})) 
            // MESH.position.z = 5
            // MESH.layers.enable(BLOOM_SCENE)
            // scene.add(MESH)

            window.addEventListener( 'resize', resize, false);
            update();
            
        }

        function RoadGenerator() {
            for(let i=0; i<maxLandscapeLength; i++) {
                const LandscapeItem = createLandscapeItem(
                    new THREE.Mesh(loadFBXLandscape.children[3].geometry, loadFBXLandscape.children[3].material),
                    new THREE.Mesh(loadFBXLandscape.children[0].geometry, new THREE.MeshBasicMaterial({color: 0x9100E7}))
                )
                scene.add(LandscapeItem)

                LandscapeItem.position.add(new THREE.Vector3(0, 0, -i*2))
                LandscapeItem.rotateX(-Math.PI / 2);
                // LandscapeItem.scale.set(0.1,0.1,0.1)
                landscapeList.enqueue(LandscapeItem);
            }
        }

        function createLandscapeItem(mesh, meshCell) {
            meshCell.layers.enable(BLOOM_SCENE);
            const LandscapeItem = new THREE.Object3D()
            LandscapeItem.name = `landscapeItem - ${LandscapeItem.uuid}`
            LandscapeItem.add(mesh)
            LandscapeItem.add(meshCell)
            return LandscapeItem
        }

        function removeObject3d(obj){
            obj.children.forEach( mesh => {
                mesh.geometry.dispose()
                mesh.material.dispose()
                scene.remove(mesh)
            })
            scene.remove(obj);
        }

        function update() {
            requestAnimationFrame( update );

            if (typeof landscapeList.size === 'function' && landscapeList.size() === maxLandscapeLength)
                landscapeList.getArr().forEach(el => {
                    el.position.z += 0.01;
            })

            if ( typeof landscapeList.size === 'function' && 
                landscapeList.size() > 0 &&
                landscapeList.getArr()[0].position.z >= 2) {
                    let oldElement = landscapeList.dequeue();
                    oldElement.position.z = -(maxLandscapeLength -1)* 2
                    landscapeList.enqueue(oldElement)
            }
            // console.log(scene)
            // renderBloom()
            renderBloom()
            finalComposer.render();
            // bloomComposer.render();
        }

        function renderBloom() {
            scene.traverse(darkenNonBloomed);
            bloomComposer.render();
            scene.traverse(restoreMaterial);
        }

        function darkenNonBloomed(obj) { // non-bloomed stuff must be black, including scene background
            if (obj.isMesh && bloomLayer.test(obj.layers) === false) {
            materials[obj.uuid] = obj.material;
            obj.material = darkMaterial;
            }
            renderer.setClearColor(0x000000);
        }

        function restoreMaterial(obj) {
            if (materials[obj.uuid]) {
            obj.material = materials[obj.uuid];
            delete materials[obj.uuid];
            }
            renderer.setClearColor(0x332233);
        }

        function resize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );
        }

        function loadBoxSky() {
            let materialArray = [];
            let texture_ft = new THREE.TextureLoader().load( 'models/sun.jpg');
            let texture_bk = new THREE.TextureLoader().load( 'models/sun.jpg');
            let texture_up = new THREE.TextureLoader().load( 'models/black.jpeg');
            let texture_dn = new THREE.TextureLoader().load( 'models/black.jpeg');
            let texture_rt = new THREE.TextureLoader().load( 'models/sun.jpg');
            let texture_lf = new THREE.TextureLoader().load( 'models/sun3.jpg');
            
            materialArray.push(new THREE.MeshBasicMaterial( { map: texture_ft }));
            materialArray.push(new THREE.MeshBasicMaterial( { map: texture_bk }));
            materialArray.push(new THREE.MeshBasicMaterial( { map: texture_up }));
            materialArray.push(new THREE.MeshBasicMaterial( { map: texture_dn }));
            materialArray.push(new THREE.MeshBasicMaterial( { map: texture_rt }));
            materialArray.push(new THREE.MeshBasicMaterial( { map: texture_lf }));
            
            for (let i = 0; i < 6; i++)
            materialArray[i].side = THREE.BackSide;
            
            let skyboxGeo = new THREE.BoxGeometry( 2000, 1400, 2300);
            let skybox = new THREE.Mesh( skyboxGeo, materialArray );
            scene.add( skybox );
        }

        function Queue() {
            this._oldestIndex = 1;
            this._newestIndex = 1;
            this._storage = {};
        }

        Queue.prototype.size = function() {
            return (this._newestIndex - this._oldestIndex);
        };

        Queue.prototype.enqueue = function(data) {
            this._storage[this._newestIndex] = data;
            this._newestIndex++;
        };

        Queue.prototype.dequeue = function() {
            let oldestIndex = this._oldestIndex,
                newestIndex = this._newestIndex,
                deletedData;

            if (oldestIndex !== newestIndex) {
                deletedData = this._storage[oldestIndex];
                delete this._storage[oldestIndex];
                this._oldestIndex++;

                return deletedData;
            }
        };

        Queue.prototype.getArr = function() {
            let arr = []
            for(let prop in this._storage) {
                arr.push(this._storage[prop])
            }
            return arr
        }

    </script>
</body>
</html>